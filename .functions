#!/usr/bin/env zsh

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$_"
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile="${@%/}.tar"
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

	size=$(
		stat -f"%z" "${tmpFile}" 2>/dev/null # macOS `stat`
		stat -c"%s" "${tmpFile}" 2>/dev/null # GNU `stat`
	)

	local cmd=""
	if ((size < 52428800)) && hash zopfli 2>/dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli"
	else
		if hash pigz 2>/dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…"
	"${cmd}" -v "${tmpFile}" || return 1
	[ -f "${tmpFile}" ] && rm "${tmpFile}"

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2>/dev/null # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2>/dev/null # GNU `stat`
	)

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully."
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null >/dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* ./*
	fi
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

# Create a data URL from a file
function dataurl() {
	local mimeType=$(file -b --mime-type "$1")
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8"
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
	local port="${1:-4000}"
	local ip=$(ipconfig getifaddr en1)
	sleep 1 && open "http://${ip}:${port}/" &
	php -S "${ip}:${port}"
}

# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c <"$1")
	local gzipsize=$(gzip -c "$1" | wc -c)
	local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Run `dig` and display the most useful info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified."
		return 1
	fi

	local domain="${1}"
	echo "Testing ${domain}…"
	echo "" # newline

	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" |
		openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1)

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText=$(echo "${tmp}" |
			openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version")
		echo "Common Name:"
		echo "" # newline
		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//"
		echo "" # newline
		echo "Subject Alternative Name(s):"
		echo "" # newline
		echo "${certText}" | grep -A 1 "Subject Alternative Name:" |
			sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
		return 0
	else
		echo "ERROR: Certificate not found."
		return 1
	fi
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ ! $(uname -s) = 'Darwin' ]; then
	if grep -q Microsoft /proc/version; then
		# Ubuntu on Windows using the Linux subsystem
		alias open='explorer.exe'
	else
		alias open='xdg-open'
	fi
fi

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
	if [ $# -eq 0 ]; then
		open .
	else
		open "$@"
	fi
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

# Image optimization - https://stackoverflow.com/a/19327447
function png() {
	pngcrush -brute "$1"{,.} && du -sh "$1"{,.}
}
function mpng() {
	mv "$1"{.,}
}

# klogs, but with timestamps converted to Pacific Time
function lklogs() {
	klogs "$@" | while read line; do
		date=$(echo $line | awk '{print $2}')
		tdate=$(TZ='America/Los_Angeles' date --date="$date")
		echo $line | awk -vt="$tdate" '{print $1 " " t " " substr($0, index($0,$3))}'
	done
}

# Generate a random mac address and change the local mac address to that
function spoof-mac() {
	sudo ifconfig en0 ether $(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
}

function httpstat() {
	docker run --rm -it dockerepo/httpstat "$@"
}

# Print list of all branches that don't exist on the remote
function localbranches() {
	EXISTING=$(git branch -r | awk 'BEGIN { FS = "/" } ; { print $2 }')
	for b in $(git branch | grep -v '*'); do
		if [[ "$EXISTING" != *"$b"* ]]; then
			echo $b
		fi
	done
}

function awssecret() {
	JSON=$(aws secretsmanager \
		get-secret-value \
		--secret-id $1 |
		jq -r '.SecretString | fromjson')
	if [[ -z ${2+x} ]]; then
		:
	else
		JSON=$(echo $JSON | jq -r $2)
	fi
	echo $JSON
}

function prunesqaushed() {
	git checkout -q master
	git for-each-ref refs/heads/ "--format=%(refname:short)" |
		while read branch; do
			mergeBase=$(git merge-base master $branch)
			tree=$(git rev-parse $branch^{tree})
			newcommit=$(git commit-tree $tree -p $mergeBase -m _)
			cherry=$(git cherry master $newcommit)
			if [[ $cherry == "-"* ]]; then
				echo "$branch is merged into master and will be deleted"
				git branch -D $branch
			fi
		done
}

function creategif() {
	filename="${1%.*}"
	ffmpeg \
		-t 4 \
		-i $1 \
		-i ~/Documents/Windsor/assets/play_icon.png \
		-filter_complex "[1:v]scale=300:300,format=argb,geq=r='r(X,Y)':a='0.8*alpha(X,Y)'[ovrl];[0:v][ovrl]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2,fps=10,scale=380:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" \
		-loop 0 \
		-y \
		"$filename.gif"
}

function timezsh() {
	shell=${1-$SHELL}
	for i in $(seq 1 10); do /usr/bin/time $shell -i -c exit; done
}

function speedgif() {
	filename="${1%.*}"
	output="$filename.speed.gif"

	small="$filename.small.gif"
	unoptimized="$filename.unoptimized.gif"

	if [[ -n $2 ]]; then
		echo Resizing GIF
		gifsicle --colors=255 --resize-fit-width $2 $1 -o $small
	else
		echo Recolorizing GIF
		gifsicle --colors=255 $1 -o $small
	fi

	echo Unoptimizing GIF
	gifsicle -U $small -o $unoptimized

	# Get the number of frames
	osname="$(uname -s)"
	if [[ $osname -eq "Darwin" ]]; then
		numframes=$(gifsicle $unoptimized -I | head -n 1 | awk '{print $3}')
	else
		numframes=$(gifsicle $unoptimized -I | grep -P "\d+ images" --only-matching | grep -P "\d+" --only-matching)
	fi

	echo "Number of frames in GIF: $numframes"

	gifsicle $unoptimized $(seq -f "#%g" 0 2 $numframes) -O3 --lossy=30 -o "$output"

	echo "Clean up"
	rm $small $unoptimized
}

function splitcsv() {
	local base="$(basename ${1%.csv})"
	split -l $2 -d $1 "${base}_";
	for i in $(find ${base}_*); do mv $i "$i.csv"; done
	for i in $(find . -type f -name "${base}_*.csv" -not -name "${base}_00.csv");
		do echo -e "$(head -1 ${base}_00.csv)\n$(cat $i)" > $i; done
}

# Clone a repo in the ~/github/{org}/{repo} format
# Usage: ghclone org/repo  OR  ghclone https://github.com/org/repo
function ghc() {
  if [[ -z "$1" ]]; then
    echo "Usage: ghclone org/repo or ghclone https://github.com/org/repo"
    return 1
  fi
  
  # Extract org and repo from different input formats
  if [[ "$1" =~ ^https?:// ]]; then
    # Handle full URL
    local repo_path=$(echo "$1" | sed -E 's#https?://github.com/([^/]+)/([^/]+)(\.git)?#\1/\2#')
  else
    # Handle org/repo format
    local repo_path="$1"
  fi
  
  local org=$(echo "$repo_path" | cut -d'/' -f1)
  local repo=$(echo "$repo_path" | cut -d'/' -f2 | sed 's/\.git$//')
  
  local target_dir="$HOME/github/$org/$repo"
  
  if [[ -d "$target_dir" ]]; then
    echo "Repository already exists at $target_dir"
    cd "$target_dir"
    return 0
  fi
  
  mkdir -p "$HOME/github/$org"
  gh repo clone "$org/$repo" "$target_dir" && cd "$target_dir"
}

# Navigate to a repo using fuzzy search
# Usage: gcd (then select from list)
function ghcd() {
  local repo=$(find ~/github -mindepth 2 -maxdepth 2 -type d | sed "s|$HOME/github/||" | fzf --preview 'cd ~/github/{} && git status')
  if [[ -n "$repo" ]]; then
    cd "$HOME/github/$repo"
  fi
}

# ==============================================================================
# Git Worktree Management Functions
# ==============================================================================

# Helper: Get the main repo root (works from worktree or subdirectory)
function _wt_get_main_repo() {
  # --git-common-dir gives us the shared .git directory (main repo's .git)
  # --path-format=absolute ensures we get absolute path
  local git_common=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null)
  if [[ -z "$git_common" ]]; then
    echo "Error: Not in a git repository" >&2
    return 1
  fi
  # Parent of .git is the repo root
  dirname "$git_common"
}

# Helper: Validate we're in ~/github/{org}/{repo} structure
function _wt_validate_github_dir() {
  local main_repo=$(_wt_get_main_repo)
  if [[ -z "$main_repo" ]]; then
    return 1
  fi

  if [[ "$main_repo" != "$HOME/github/"* ]]; then
    echo "Error: Not in ~/github/{org}/{repo} structure" >&2
    return 1
  fi
  echo "$main_repo"
}

# Worktree directory separator (repo--branch distinguishes from sibling repos like repo-name)
_WT_SEP="--"

# Helper: Sanitize branch name for directory (feature/foo -> feature-foo)
function _wt_sanitize_branch() {
  echo "$1" | sed 's|/|-|g'
}

# Create a new worktree from an existing branch
# Usage: wt [branch-name]
function wt() {
  local main_repo=$(_wt_validate_github_dir)
  if [[ -z "$main_repo" ]]; then
    return 1
  fi

  local branch="$1"

  # If no branch provided, use fzf to select from remote branches
  if [[ -z "$branch" ]]; then
    echo "Fetching remote branches..."
    git -C "$main_repo" fetch --all --prune 2>/dev/null

    branch=$(git -C "$main_repo" branch -r | grep -v HEAD | sed 's|origin/||' | sed 's/^[[:space:]]*//' | fzf --prompt="Select branch: " --preview "git -C '$main_repo' log --oneline -10 origin/{}")

    if [[ -z "$branch" ]]; then
      echo "No branch selected"
      return 1
    fi
  fi

  local sanitized=$(_wt_sanitize_branch "$branch")
  local worktree_path="${main_repo}${_WT_SEP}${sanitized}"

  if [[ -d "$worktree_path" ]]; then
    echo "Worktree already exists at $worktree_path"
    cd "$worktree_path"
    return 0
  fi

  # Create the worktree
  echo "Creating worktree at $worktree_path for branch $branch..."
  if git -C "$main_repo" worktree add "$worktree_path" "$branch" 2>/dev/null || \
     git -C "$main_repo" worktree add "$worktree_path" -b "$branch" "origin/$branch" 2>/dev/null; then
    cd "$worktree_path"
    echo "Switched to worktree: $worktree_path"
  else
    echo "Error: Failed to create worktree" >&2
    return 1
  fi
}

# List all worktrees for the current repo
# Usage: wtl
function wtl() {
  local main_repo=$(_wt_validate_github_dir)
  if [[ -z "$main_repo" ]]; then
    return 1
  fi

  git -C "$main_repo" worktree list
}

# Delete a worktree
# Usage: wtd [worktree-path-or-branch]
function wtd() {
  local main_repo=$(_wt_validate_github_dir)
  if [[ -z "$main_repo" ]]; then
    return 1
  fi

  local worktree="$1"

  # If no argument, use fzf to select
  if [[ -z "$worktree" ]]; then
    worktree=$(git -C "$main_repo" worktree list | grep -v "$main_repo " | awk '{print $1}' | fzf --prompt="Select worktree to delete: " --preview "cd {} && git status")

    if [[ -z "$worktree" ]]; then
      echo "No worktree selected"
      return 1
    fi
  fi

  # If it's a branch name, convert to path
  if [[ ! -d "$worktree" ]]; then
    local sanitized=$(_wt_sanitize_branch "$worktree")
    worktree="${main_repo}${_WT_SEP}${sanitized}"
  fi

  if [[ ! -d "$worktree" ]]; then
    echo "Error: Worktree not found: $worktree" >&2
    return 1
  fi

  # Confirm deletion
  echo -n "Delete worktree at $worktree? [y/N] "
  read -r confirm
  if [[ "$confirm" != [yY] ]]; then
    echo "Cancelled"
    return 0
  fi

  # If we're in the worktree we're deleting, cd to main repo first
  if [[ "$(pwd)" == "$worktree"* ]]; then
    cd "$main_repo"
  fi

  # Try normal remove, fall back to force if needed
  if ! git -C "$main_repo" worktree remove "$worktree" 2>/dev/null; then
    echo -n "Worktree has changes. Force delete? [y/N] "
    read -r force_confirm
    if [[ "$force_confirm" == [yY] ]]; then
      git -C "$main_repo" worktree remove --force "$worktree"
    else
      echo "Cancelled"
      return 1
    fi
  fi

  echo "Worktree deleted"
}

# Navigate to a worktree using fuzzy search
# Usage: wtcd
function wtcd() {
  local main_repo=$(_wt_validate_github_dir)
  if [[ -z "$main_repo" ]]; then
    return 1
  fi

  local worktree=$(git -C "$main_repo" worktree list | awk '{print $1}' | fzf --prompt="Select worktree: " --preview "cd {} && git status && echo '' && git log --oneline -5")

  if [[ -n "$worktree" ]]; then
    cd "$worktree"
  fi
}

# Create a new worktree with a NEW branch
# Usage: wtn <new-branch-name> [base-ref]
function wtn() {
  local main_repo=$(_wt_validate_github_dir)
  if [[ -z "$main_repo" ]]; then
    return 1
  fi

  local new_branch="$1"
  local base_ref="$2"

  if [[ -z "$new_branch" ]]; then
    echo "Usage: wtn <new-branch-name> [base-ref]" >&2
    return 1
  fi

  # Default base ref to origin/main or origin/master
  if [[ -z "$base_ref" ]]; then
    if git -C "$main_repo" rev-parse --verify origin/main &>/dev/null; then
      base_ref="origin/main"
    elif git -C "$main_repo" rev-parse --verify origin/master &>/dev/null; then
      base_ref="origin/master"
    else
      echo "Error: Could not find origin/main or origin/master. Please specify base-ref." >&2
      return 1
    fi
    # Fetch latest
    echo "Fetching latest from remote..."
    git -C "$main_repo" fetch origin
  fi

  local sanitized=$(_wt_sanitize_branch "$new_branch")
  local worktree_path="${main_repo}${_WT_SEP}${sanitized}"

  if [[ -d "$worktree_path" ]]; then
    echo "Worktree already exists at $worktree_path"
    cd "$worktree_path"
    return 0
  fi

  echo "Creating worktree at $worktree_path with new branch $new_branch (based on $base_ref)..."
  if git -C "$main_repo" worktree add -b "$new_branch" "$worktree_path" "$base_ref"; then
    cd "$worktree_path"
    echo "Switched to worktree: $worktree_path"
  else
    echo "Error: Failed to create worktree" >&2
    return 1
  fi
}

# Review a PR: checks out the branch as a worktree and launches Claude to review
# Usage: wtpr <pr-number-or-url>
function wtpr() {
  local pr_input="$1"
  if [[ -z "$pr_input" ]]; then
    echo "Usage: wtpr <pr-number> or wtpr <github-pr-url>" >&2
    return 1
  fi

  local repo_flag=""
  local pr_number=""
  local org_repo=""

  # Parse input: URL vs number
  if [[ "$pr_input" =~ ^https?:// ]]; then
    # Extract org/repo and PR number from URL
    # https://github.com/vercel/workflow/pull/123
    local url_path=$(echo "$pr_input" | sed -E 's#https?://github.com/##')
    org_repo=$(echo "$url_path" | cut -d'/' -f1-2)
    pr_number=$(echo "$url_path" | cut -d'/' -f4)
    repo_flag="-R $org_repo"
  else
    pr_number="$pr_input"
  fi

  # Get PR branch info using gh
  local pr_json=$(eval gh pr view $pr_number $repo_flag --json headRefName,title,number,url 2>/dev/null)
  if [[ -z "$pr_json" ]]; then
    echo "Error: Could not fetch PR #$pr_number" >&2
    return 1
  fi

  local branch=$(echo "$pr_json" | jq -r '.headRefName')
  local title=$(echo "$pr_json" | jq -r '.title')
  local number=$(echo "$pr_json" | jq -r '.number')
  local url=$(echo "$pr_json" | jq -r '.url')

  echo "PR #$number: $title"
  echo "Branch: $branch"

  # If we got a URL but aren't in the right repo, cd there
  if [[ -n "$repo_flag" ]]; then
    local org=$(echo "$org_repo" | cut -d'/' -f1)
    local repo=$(echo "$org_repo" | cut -d'/' -f2)
    local repo_path="$HOME/github/$org/$repo"
    if [[ ! -d "$repo_path" ]]; then
      echo "Error: Repo not found at $repo_path. Clone it first with: ghc $org_repo" >&2
      return 1
    fi
    cd "$repo_path"
  fi

  # Create worktree for the PR branch
  wt "$branch"

  # Launch Claude with review prompt
  echo "Starting Claude review for PR #$number..."
  cx "Review PR #$number ($url). The branch '$branch' is checked out locally in this directory. Do a thorough code review: deeply inspect all changed files, check the PR diff and any existing review comments on GitHub, and provide your review with inline comments on the PR."
}

# Clean up worktrees whose branches have been merged/deleted on remote
# Usage: wtclean
function wtclean() {
  local main_repo=$(_wt_validate_github_dir)
  if [[ -z "$main_repo" ]]; then return 1; fi

  echo "Fetching latest remote state..."
  git -C "$main_repo" fetch --prune

  local cleaned=0
  while read wt_path; do
    # Skip the main repo itself
    [[ "$wt_path" == "$main_repo" ]] && continue

    # Get the branch for this worktree
    local wt_branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD 2>/dev/null)
    [[ -z "$wt_branch" || "$wt_branch" == "HEAD" ]] && continue

    # Check if the branch still exists on remote
    if ! git -C "$main_repo" rev-parse --verify "origin/$wt_branch" &>/dev/null; then
      echo "  Stale: $wt_path (branch '$wt_branch' no longer on remote)"
      echo -n "  Delete? [y/N] "
      read -r confirm </dev/tty
      if [[ "$confirm" == [yY] ]]; then
        # Navigate away if we're in this worktree
        [[ "$(pwd)" == "$wt_path"* ]] && cd "$main_repo"
        git -C "$main_repo" worktree remove "$wt_path" 2>/dev/null || \
          git -C "$main_repo" worktree remove --force "$wt_path"
        echo "  Deleted."
        cleaned=$((cleaned + 1))
      fi
    fi
  done < <(git -C "$main_repo" worktree list --porcelain | grep "^worktree " | sed 's/^worktree //')

  echo "Cleaned up $cleaned worktree(s)."
}

# Quick check: warn if on main/master branch and suggest wtn
function _wt_main_guard() {
  local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  if [[ "$branch" == "main" || "$branch" == "master" ]]; then
    echo "\u26a0  You're on $branch. Create a worktree instead:"
    echo "   wtn <branch-name>    # new branch"
    echo "   wt <branch-name>     # existing branch"
    echo "   wtpr <pr-number>     # review a PR"
    return 1
  fi
}
